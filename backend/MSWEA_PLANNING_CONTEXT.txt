================================================================================
MSWEA (Multi-agent Software Engineering Arena) - Planning Context
Session Date: 2026-02-12
================================================================================

## USER REQUEST

Help implement the idea from /home/pranay5255/YudaiV3/backend/docs/post.jpg:
- "GitHub for Agents" concept where AI agents compete to solve issues
- PR as Auction: Multiple agents compete, best solution wins
- Agent Reputation: Track merged PRs, reverted commits, issue quality
- Progressive Staking: First PR cheap, if reverted next costs 10x
- Best-of-N Synthesis: Reviewer agent evaluates competing solutions

User requirements:
1. Must ship FAST
2. Trajectory streaming to TrajectoryViewer (poll every 2s, NOT websockets)
3. Must work with docker-compose.prod.yml deployment
4. Simplify to MVP

================================================================================
## EXISTING CODEBASE ANALYSIS
================================================================================

### Backend Architecture (FastAPI + PostgreSQL + E2B Sandboxes)

**Current Solver Flow:**
1. User selects GitHub issue → POST /api/daifu/sessions/{id}/solve/start
2. DefaultSolverManager creates Solve + SolveRun records
3. Runs execute SEQUENTIALLY in E2B sandboxes (HeadlessSandboxExecutor)
4. First successful run becomes champion (first-wins)
5. Frontend polls GET /solve/status/{solveId} every 3 seconds
6. Agent script generates trajectory file (.traj.json) saved to /tmp/yudai/trajectories/

**Key Files:**
- solver/manager.py (863 lines) - DefaultSolverManager orchestrates solve sessions
- solver/sandbox.py (812 lines) - HeadlessSandboxExecutor manages E2B sandboxes
- solver/agentScriptGen.py (752 lines) - Generates Python scripts for agent execution
- solver/solver.py - FastAPI router with 3 endpoints (start, status, cancel)
- models.py (1400+ lines) - SQLAlchemy + Pydantic models

**Database Models:**
- Solve: id, user_id, session_id, repo_url, issue_number, status, matrix (JSON),
  champion_run_id, max_parallel, time_budget_s
- SolveRun: id, solve_id, model, temperature, status, pr_url, tests_passed,
  trajectory_data (JSON), diagnostics (JSON)
- AIModel: id, name, provider, model_id, pricing info

**CRITICAL: Multi-model support ALREADY EXISTS in types**
```python
# In StartSolveRequest
ai_model_id?: number;      # Single model (current UI uses this)
ai_model_ids?: number[];   # Multiple models (ALREADY DEFINED but unused)
```

**Trajectory Data Storage:**
- Agent execution generates /home/user/last_mini_run.traj.json in E2B sandbox
- HeadlessSandboxExecutor downloads to /tmp/yudai/trajectories/{repo}_{solve_id}_{run_id}.traj.json
- Metadata stored in SolveRun.trajectory_data as JSON:
  {
    "remote_path": "...",
    "local_path": "...",
    "metadata": {
      "exit_status": "...",
      "instance_cost": 0.05,
      "api_calls": 120,
      "total_messages": 240
    }
  }

**GitHub Integration:**
- OAuth via GitHub App (auth/github_oauth.py)
- User tokens stored in AuthToken table
- GitHubOps class (daifuUserAgent/githubOps.py) for all GitHub API operations
- CURRENT GAP: Solver uses server-wide GITHUB_TOKEN env var, not per-user OAuth tokens

================================================================================
## FRONTEND ARCHITECTURE (React + TypeScript + TanStack Query)
================================================================================

**Tech Stack:**
- React 18.3.1 + TypeScript
- Vite 5.4.19 (build tool)
- React Router DOM v7.8.2
- Zustand 5.0.8 (local state)
- TanStack React Query 5.85.5 (server state/caching)
- Tailwind CSS 3.4.1 (custom "Terminal Precision" design system)

**Solver UI Components:**
- src/components/SolveIssues.tsx (749 lines)
  - IssueModal: Configuration dialog with model selector, checkboxes
  - SolveProgressModal: Real-time status with 3s polling
  - Already displays multiple runs + champion highlighting
  - Already has progress stats (total, completed, running, failed)

**Trajectory Viewer:**
- src/components/TrajectoryViewer.tsx (253 lines)
- Currently loads static JSON from src/data/last_mini_run.traj.json
- Interface TrajectoryData:
  {
    info: {
      exit_status: string,
      submission: string,
      model_stats: { instance_cost, api_calls },
      mini_version: string,
      config: { model: { model_name } }
    },
    messages: [{ role: string, content: string }]
  }
- Shows expandable message list with role badges (system/user/assistant)
- Stats dashboard: cost, API calls, message count, status

**USER REQUIREMENT: Arena must stream trajectory to TrajectoryViewer**
- Poll E2B server every 2s for trajectory updates
- Update TrajectoryViewer in real-time during agent execution
- NO websockets (deployment complexity)

**Type Definitions:**
- src/types/sessionTypes.ts already has SolveStatusResponse with:
  - progress: SolveProgress (runs_total, runs_completed, runs_failed, runs_running)
  - runs: SolveRunOut[] (array of individual runs)
  - champion_run?: SolveRunOut

================================================================================
## DEPLOYMENT INFRASTRUCTURE
================================================================================

**CRITICAL GAP: User mentioned docker-compose.prod.yml but exploration agents failed**

Need to investigate:
1. How is backend containerized? (Dockerfile, docker-compose.yml)
2. How is frontend built and served? (nginx? static files?)
3. What databases are configured? (PostgreSQL connection)
4. What environment variables are needed?
5. How are E2B API keys configured?
6. Any reverse proxy setup?

**This is a blocker for deployment planning.**

================================================================================
## TRAJECTORY STREAMING REQUIREMENTS
================================================================================

**User's Vision:**
1. When arena starts, multiple contestants run in parallel
2. Each contestant's trajectory must stream to UI in real-time
3. Frontend polls E2B server every 2s to fetch latest trajectory
4. TrajectoryViewer updates incrementally (append new messages)
5. NO websockets (too complex for deployment)

**Implementation Questions:**
1. How to expose E2B sandbox trajectory during execution?
   - E2B sandbox is ephemeral, runs in cloud
   - Agent writes to /home/user/last_mini_run.traj.json progressively
   - Need endpoint to fetch partial trajectory from running sandbox

2. Where does trajectory polling endpoint live?
   - Backend needs to proxy E2B sandbox file reads
   - Endpoint: GET /api/daifu/arena/sessions/{sid}/trajectories/{contestant_id}
   - Returns current state of trajectory (may be incomplete)

3. How to handle multiple concurrent trajectories (arena with 3-4 agents)?
   - Each contestant has own sandbox_id
   - Each gets own trajectory stream
   - UI tabs or split view to show all trajectories side-by-side?

4. When to switch from polling to final trajectory?
   - While status=RUNNING: poll every 2s for incremental updates
   - When status=COMPLETED: fetch final trajectory from /tmp/yudai/trajectories/

================================================================================
## MVP SIMPLIFICATION STRATEGY
================================================================================

**Skip for V1:**
1. LLM Evaluator (evaluator.py) - Use simple heuristic: first tests_passed=True wins
2. Reputation System (reputation.py) - No reputation tracking or progressive staking
3. AgentReputation table - No DB overhead
4. Reduce strategies from 4 to 3: minimal-fix, test-first, balanced

**Keep for V1:**
1. Arena orchestrator with parallel execution (arena.py)
2. Strategy system (strategies.py) - different agent personas
3. Arena + ArenaContestant tables
4. Trajectory streaming to TrajectoryViewer
5. Arena mode toggle in UI

**Deployment Constraints (MUST INVESTIGATE):**
- Must work with docker-compose.prod.yml
- Must handle E2B API keys securely
- Must not add complex dependencies (no websockets)
- Must support PostgreSQL connection pooling

================================================================================
## CRITICAL UNKNOWNS (NEED TO INVESTIGATE)
================================================================================

1. **Docker deployment config**
   - docker-compose.prod.yml structure?
   - Dockerfile for backend?
   - nginx config for frontend?
   - Environment variable management?

2. **Trajectory streaming technical approach**
   - Can we read from E2B sandbox mid-execution?
   - E2B SDK support for file reads from running sandboxes?
   - How to handle partial JSON reads (trajectory file being written)?

3. **Frontend trajectory polling**
   - Where to store trajectory state? (React Query? Zustand?)
   - How to merge incremental updates? (append messages)
   - UI for multi-contestant trajectory view?

4. **Arena UI integration**
   - Does TrajectoryViewer need tabs for each contestant?
   - Where does arena mode live? (new tab or toggle in SolveIssues?)
   - Strategy selection UI design?

================================================================================
## NEXT STEPS
================================================================================

1. READ docker-compose.prod.yml and Dockerfile to understand deployment
2. READ E2B SDK docs to understand mid-execution file reads
3. DESIGN trajectory streaming architecture
4. DESIGN arena UI with trajectory integration
5. UPDATE plan with deployment-aware implementation

================================================================================
## DESIGN SYSTEM (from design-doc.md)
================================================================================

**Terminal Precision Aesthetic:**
- Monospace typography (JetBrains Mono, IBM Plex Mono)
- Deep charcoal backgrounds (#0a0a0b, #111113, #1a1a1d)
- Amber primary accent (#f59e0b), Cyan secondary (#22d3ee)
- Border colors (#2a2a2e, #3d3d42)
- Text colors (#f4f4f5, #a1a1aa, #71717a)

**Component Patterns:**
- Rounded corners (rounded-lg, rounded-xl)
- Border styles (border border-border)
- Hover effects (hover:border-amber/30)
- Animation delays for staggered entry
- Terminal-inspired noise texture overlay

================================================================================
## FILE STRUCTURE REFERENCE
================================================================================

Backend:
/home/pranay5255/YudaiV3/backend/
├── solver/
│   ├── manager.py (DefaultSolverManager)
│   ├── sandbox.py (HeadlessSandboxExecutor)
│   ├── agentScriptGen.py
│   ├── solver.py (FastAPI router)
│   └── mswea/ (NEW - to be created)
│       ├── __init__.py
│       ├── models.py (Arena, ArenaContestant tables)
│       ├── strategies.py (3 built-in strategies)
│       ├── arena.py (ArenaOrchestrator)
│       └── routes.py (3 FastAPI endpoints)
├── models.py (unified SQLAlchemy + Pydantic)
├── db/database.py
├── run_server.py
└── docs/post.jpg (original idea image)

Frontend:
/home/pranay5255/YudaiV3/src/
├── components/
│   ├── SolveIssues.tsx (IssueModal, SolveProgressModal)
│   └── TrajectoryViewer.tsx (trajectory display)
├── types/sessionTypes.ts
├── hooks/
│   ├── useSessionQueries.ts
│   └── useSessionManagement.ts
├── stores/
│   ├── authStore.ts
│   └── sessionStore.ts
└── data/last_mini_run.traj.json (example trajectory)

================================================================================
## TRAJECTORY FILE FORMAT (from last_mini_run.traj.json)
================================================================================

{
  "info": {
    "exit_status": "submitted",
    "submission": "...",
    "model_stats": {
      "instance_cost": 0.0524,
      "api_calls": 123,
      "tokens_sent": 45678,
      "tokens_received": 23456,
      "completion_cost": 0.0312,
      "prompt_cost": 0.0212
    },
    "mini_version": "0.2.1",
    "config": {
      "model": {
        "model_name": "anthropic/claude-sonnet-4-5-20250929",
        "temperature": 0.1
      }
    }
  },
  "messages": [
    { "role": "system", "content": "You are a software engineering agent..." },
    { "role": "user", "content": "Please fix issue #123..." },
    { "role": "assistant", "content": "I'll analyze the issue..." },
    ...
  ]
}

**Key observation:**
- File is written incrementally by mini-swe-agent
- Each message added as agent progresses
- Final "info" section written at end
- Need to handle partial reads (file may be incomplete during execution)

================================================================================
## BLOCKERS SUMMARY
================================================================================

1. **DEPLOYMENT CONFIG UNKNOWN** - Need docker-compose.prod.yml details
2. **E2B TRAJECTORY STREAMING** - Need to verify E2B SDK supports mid-execution file reads
3. **TRAJECTORY UI DESIGN** - Need to design multi-contestant trajectory view
4. **ARENA UI PLACEMENT** - Where does arena mode toggle go? New tab vs modal toggle?

================================================================================
## END OF CONTEXT DUMP
================================================================================

## PROD ENV SETUP & TESTING REPORT (MSWEA ARENA MVP)
Generated: 2026-02-12

### Scope
Environment variables needed to do **complete production setup and testing** for:
- Arena mode (parallel contestants)
- 2-second trajectory polling (`/solve/trajectory/...`)
- GitHub issue solving + PR flow
- Docker Compose production deployment

### 1. Required `.env.prod` variables (set explicitly)

| ENV | Required For | Why |
|---|---|---|
| `POSTGRES_DB` | DB container + backend DB URL | Creates/targets production DB |
| `POSTGRES_USER` | DB container + backend DB URL | DB authentication |
| `POSTGRES_PASSWORD` | DB container + backend DB URL | DB authentication |
| `OPENROUTER_API_KEY` | Solver/LLM execution | Required by sandbox executor and LLM service |
| `E2B_API_KEY` | Sandbox execution | Required to create/run E2B sandboxes |
| `GITHUB_APP_ID` | GitHub App OAuth | App identity + server auth |
| `GITHUB_APP_CLIENT_ID` | GitHub OAuth flow | User login/authorization |
| `GITHUB_APP_CLIENT_SECRET` | GitHub OAuth flow | Token exchange |
| `GITHUB_APP_INSTALLATION_ID` | GitHub App integration | Installation-scoped API operations |
| `GITHUB_REDIRECT_URI` | OAuth callback | Must match GitHub App config |
| `FRONTEND_URL` | CORS + OAuth | Backend allowlist + redirect flow |
| `DOMAIN` | API/domain wiring | Used in backend domain config |
| `SECRET_KEY` | App security | Backend secret use |
| `JWT_SECRET` | Session/auth security | JWT signing/validation |

### 2. Strongly recommended explicit vars (avoid relying on defaults)

| ENV | Current Default | Why Set Explicitly in Prod |
|---|---|---|
| `BACKEND_URL` | `https://yudai.app/api` | Prevent wrong API origin in non-default domains |
| `HOST` | `0.0.0.0` | Explicit bind behavior |
| `PORT` | `8000` | Explicit runtime port |
| `SALT` | `yudai-salt` | Avoid shared/default salt |
| `PYTHONUNBUFFERED` | `1` | Deterministic container logging |
| `PYTHONDONTWRITEBYTECODE` | `1` | Deterministic container behavior |

### 3. Arena/solver tuning vars (recommended for full prod testing)

| ENV | Suggested Test Value | Purpose |
|---|---|---|
| `SOLVER_MAX_PARALLEL` | `3` | Max concurrent solve sessions |
| `SOLVER_TIME_BUDGET_SECONDS` | `5400` | Overall solve budget per solve |
| `SOLVER_ARENA_MAX_RUNS` | `6` | Cap arena contestants per solve |
| `TRAJECTORY_STORAGE_DIR` | `/tmp/yudai/trajectories` | Local trajectory cache path |

### 4. Optional fallback var

| ENV | When Needed | Notes |
|---|---|---|
| `GITHUB_TOKEN` | If user OAuth token is unavailable | Fallback token path for solver; OAuth user token is preferred for prod |

### 5. Minimal `.env.prod` example for complete setup/testing

```dotenv
# Database
POSTGRES_DB=yudai_prod
POSTGRES_USER=yudai_user
POSTGRES_PASSWORD=replace_me

# Security
SECRET_KEY=replace_me
JWT_SECRET=replace_me
SALT=replace_me

# Domain / URLs
DOMAIN=your-domain.com
FRONTEND_URL=https://your-domain.com
BACKEND_URL=https://your-domain.com/api
GITHUB_REDIRECT_URI=https://your-domain.com/auth/callback
HOST=0.0.0.0
PORT=8000

# Core integrations
OPENROUTER_API_KEY=replace_me
E2B_API_KEY=replace_me

# GitHub App OAuth
GITHUB_APP_ID=replace_me
GITHUB_APP_CLIENT_ID=replace_me
GITHUB_APP_CLIENT_SECRET=replace_me
GITHUB_APP_INSTALLATION_ID=replace_me

# Runtime
PYTHONUNBUFFERED=1
PYTHONDONTWRITEBYTECODE=1

# Arena/solver tuning
SOLVER_MAX_PARALLEL=3
SOLVER_TIME_BUDGET_SECONDS=5400
SOLVER_ARENA_MAX_RUNS=6
TRAJECTORY_STORAGE_DIR=/tmp/yudai/trajectories

# Optional fallback
# GITHUB_TOKEN=replace_me
```

### 6. Non-env blocker to verify (required for setup completeness)
- GitHub App private key file must exist and be mounted at:
  - `./backend/yudaiv3.2025-09-07.private-key.pem`
  - container path: `/app/yudaiv3.2025-09-07.private-key.pem`
